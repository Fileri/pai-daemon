# PAI Daemon Architecture

## Overview

The PAI Daemon is an event bus for Personal AI Infrastructure. It collects telemetry from Claude Code sessions and enables real-time monitoring and bidirectional communication with external systems.

## Architecture

```
┌─────────────────┐     POST      ┌─────────────────┐     WebSocket    ┌───────────────┐
│  Claude Code    │──────────────→│                 │←────────────────→│   Dashboard   │
│  (hooks)        │               │   pai-daemon    │                  │   (real-time) │
└─────────────────┘               │   (event bus)   │                  └───────────────┘
                                  │                 │
┌─────────────────┐     POST      │                 │     WebSocket    ┌───────────────┐
│      n8n        │──────────────→│                 │────────────────→ │ Claude Code   │
│   (webhooks)    │               └─────────────────┘                  │ (future)      │
└─────────────────┘                                                    └───────────────┘
```

## Design Decisions

### HTTP for Ingestion

Claude Code hooks are ephemeral shell scripts — each hook invocation spawns a new process, runs, and exits. There's no persistent process to maintain a WebSocket connection.

**Flow:**
```
Hook fires → script runs → POST /events → script exits
```

HTTP POST is the natural fit for this fire-and-forget pattern.

### WebSocket for Real-time Consumers

Dashboards and monitoring tools need real-time event streams. WebSocket provides:
- Low-latency event delivery
- Bidirectional communication (for future n8n → client notifications)
- Persistent connections for subscribers

### Event Bus Pattern

The daemon acts as a central hub:
1. **Ingestion**: Accepts events via HTTP POST
2. **Broadcast**: Pushes events to all connected WebSocket clients
3. **Storage**: Persists events for querying (future)

## API Endpoints

### `POST /events`

Ingest events from any source (hooks, n8n, etc.).

**Request:**
```json
{
  "type": "session.start",
  "timestamp": "2026-01-16T19:30:00Z",
  "metadata": {
    "sessionId": "abc123",
    "workingDirectory": "/Users/erik/code/project"
  }
}
```

**Response:**
```json
{
  "ok": true,
  "eventId": "evt_123"
}
```

### `GET /events`

Query recent events (future implementation).

**Query params:**
- `type` - Filter by event type
- `since` - Events after timestamp
- `limit` - Max events to return

### `WS /ws`

Subscribe to real-time event stream.

**Connection:** `ws://pai-daemon:3000/ws`

**Messages (server → client):**
```json
{
  "type": "event",
  "data": {
    "id": "evt_123",
    "type": "session.start",
    "timestamp": "2026-01-16T19:30:00Z",
    "metadata": { ... }
  }
}
```

### `GET /health`

Health check for Kubernetes liveness probe.

**Response:** `{"status":"ok"}`

### `GET /ready`

Readiness check for Kubernetes readiness probe.

**Response:** `{"ready":true}`

## Event Schema

All events follow this structure:

```typescript
interface PAIEvent {
  id: string;           // Generated by daemon
  type: string;         // Event type (e.g., "session.start")
  timestamp: string;    // ISO 8601 timestamp
  metadata: Record<string, unknown>;  // Event-specific data
}
```

## Deployment

### Kubernetes

Deployed via FluxCD from the `k8s/` directory:
- Namespace: `pai`
- Service: `pai-daemon` (ClusterIP, port 80 → 3000)
- Ingress: `pai.v10b.no` with TLS

### Infrastructure

- **Cluster**: 3-node Talos Linux on GCE
- **Network**: Tailscale mesh (private access)
- **GitOps**: FluxCD syncs from `main` branch

## Future Considerations

### Bidirectional Communication

For n8n → Claude Code notifications:
1. Requires a persistent WebSocket client in Claude Code
2. Could be a background daemon process
3. Would enable workflow triggers, alerts, etc.

### Persistence

Current: In-memory event buffer
Future options:
- SQLite for simple persistence
- PostgreSQL for production workloads
- ClickHouse for analytics at scale

### Authentication

Current: None (private Tailscale network)
Future: API keys or JWT for multi-tenant scenarios
